#pragma once
#include <functional>
#include <cmath>
#include <array>
// Brent Method code from Boost, modified to remove any dependence on boost
// https://github.com/boostorg/math/blob/boost-1.89.0/include/boost/math/tools/minima.hpp

// Software liscence to accompay Boost Code
// Boost Software License - Version 1.0 - August 17th, 2003

// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.


/// @brief Compute the minima via brents_method
/// @param f function to be evaluated
/// @param min lower interval limit
/// @param max upper interval limit 
/// @param tolerance Tolerance on interval change. Should be larger than 1e-8, as this is the
///                  maximum accuracy one can get for computing a minimum.
/// @param max_iter Maximum number of iterations
/// @return An array with the xmin in the first index, and f(xmin) in the second index
std::array<double, 2> brent_find_minima(const std::function<double(double)>& f, double min, 
      double max, double tolerance = 1e-6, int max_iter=100)
{
   
   double x;  // minima so far
   double w;  // second best point
   double v;  // previous value of w
   double u;  // most recent evaluation point
   double delta;  // The distance moved in the last step
   double delta2; // The distance moved in the step before last
   double fu, fv, fw, fx;  // function evaluations at u, v, w, x
   double mid; // midpoint of min and max
   double fract1, fract2;  // minimal relative movement in x

   static const double golden = 0.3819660f;  // golden ratio, don't need too much precision here!

   x = w = v = max;
   fw = fv = fx = f(x);
   delta2 = delta = 0;

   int count = max_iter;

   do{
      // get midpoint
      mid = (min + max) / 2;
      // work out if we're done already:
      fract1 = tolerance * std::fabs(x) + tolerance / 4;
      fract2 = 2 * fract1;
      if(std::fabs(x - mid) <= (fract2 - (max - min) / 2))
         break;

      if(std::fabs(delta2) > fract1)
      {
         // try and construct a parabolic fit:
         double r = (x - w) * (fx - fv);
         double q = (x - v) * (fx - fw);
         double p = (x - v) * q - (x - w) * r;
         q = 2 * (q - r);
         if(q > 0)
            p = -p;
         q = std::fabs(q);
         double td = delta2;
         delta2 = delta;
         // determine whether a parabolic step is acceptable or not:
         if((std::fabs(p) >= std::fabs(q * td / 2)) || (p <= q * (min - x)) || (p >= q * (max - x)))
         {
            // nope, try golden section instead
            delta2 = (x >= mid) ? min - x : max - x;
            delta = golden * delta2;
         }
         else
         {
            // whew, parabolic fit:
            delta = p / q;
            u = x + delta;
            if(((u - min) < fract2) || ((max- u) < fract2))
               delta = (mid - x) < 0 ? (double)-std::fabs(fract1) : (double)std::fabs(fract1);
         }
      }
      else
      {
         // golden section:
         delta2 = (x >= mid) ? min - x : max - x;
         delta = golden * delta2;
      }
      // update current position:
      u = (std::fabs(delta) >= fract1) ? double(x + delta) : (delta > 0 ? double(x + std::fabs(fract1)) : double(x - std::fabs(fract1)));
      fu = f(u);
      if(fu <= fx)
      {
         // good new point is an improvement!
         // update brackets:
         if(u >= x)
            min = x;
         else
            max = x;
         // update control points:
         v = w;
         w = x;
         x = u;
         fv = fw;
         fw = fx;
         fx = fu;
      }
      else
      {
         // Oh dear, point u is worse than what we have already,
         // even so it *must* be better than one of our endpoints:
         if(u < x)
            min = u;
         else
            max = u;
         if((fu <= fw) || (w == x))
         {
            // however it is at least second best:
            v = w;
            w = u;
            fv = fw;
            fw = fu;
         }
         else if((fu <= fv) || (v == x) || (v == w))
         {
            // third best:
            v = u;
            fv = fu;
         }
      }

   }while(--count);

   max_iter -= count;

   
   return std::array<double,2> {x, fx};
}
